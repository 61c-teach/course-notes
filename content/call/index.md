---
title: "CALL Overview"
---

(sec-call)=
## Learning Outcomes

* Identify the four steps of translating and running a program: Compile, Assemble, Link, and Load (CALL).

In this lecture, we will learn how to run a program. We will give more details to our **colloquial** definition of compiling C code to a binary executable:

:::{figure} images/compile-high-level.png
:label: fig-compile-high-level
:width: 100%
:alt: "TODO"

Colloquially, "compiling C code" has translated a program `foo.c` to some executable `a.out`. But how and where does assembly get involved?
:::


Let's come back to [The Great Idea of Abstraction](#fig-great-idea-1). Today, we will discuss everything **above** the orange ISA lineâ€“how to go from a high-level language like C to a lower-level assembly language, and then finally to the lowest-level machine code.

## Translate and Run a Program

We will spend today discussing @fig-call-flow.

The process of **translating** a C program `foo.c` from the high-level C code to a machine executable `a.out` is actually three steps (Compile, Assemble, Link), plus an additional step for running the program (Load). Notably, the first three steps spell CALâ€“Go Bears!!!


:::{figure} images/call-flow.png
:label: fig-call-flow
:width: 60%
:alt: "TODO"

Flow chart for steps for compiling and running a C program.
:::

The high-level details are shown in @tab-call-flow:

:::{table} Input/output of each step of CALL.
:label: tab-call-flow

| Step | Input | Output | Notes |
| :-- | :-- | :-- | :-- |
| [**Compiler**](#sec-compiler) | High-level Language Code (e.g., `foo.c`) | Assembly Language Code (e.g., `foo.s`) | Output may contain pseudoinstructions (`mv`, `li`, `j`, etc.) |
| [**Assembler**](#sec-assembler) | Assembly Language Code (e.g., `foo.s`) | Machine Language Module object file (e.g., `foo.o`) | Replace pseudoinstructions with true assembly instructions; produce an object file (module). |
| [**Linker**](#sec-linker) | Object files (e.g., `foo.o`, `lib.o` | Executable machine code (e.g., `a.out`) | The Linker enables separate compilation of files. Changes to one file does not require recompilation of the entire program.|
| [**Loader**](#sec-loader) | Executable Code (e.g., `a.out`) | (program is run) | When an executable is run, the loader first loads the executable file from disk into memory and then runs the executable. |

:::

(sec-compiler)=
### Compiler

::::{note} ðŸŽ¥ Lecture Video: Compiler
:class: dropdown

:::{iframe} https://www.youtube.com/embed/QrRbiNPz-Kw
:width: 100%
:title: "[CS61C FA20] Lecture 13.2 - Compilation, Assembly, Linking, Loading: Compiler"

Most of this video discusses the CALL overview above.
:::

::::

The compiler translates C code to assembly code. Generally, we use a program like `gcc` to **compile** programs for us. In this class, we've practiced **hand-authoring** RISC-V with the Venus simulator.

Importantly, the compiler assembly output can include **pseudo-instructions**. As mentioned in an [earlier section](#sec-pseudoinstructions), pseudoinstructions (e.g., `mv t1 t2`) make it much easier to write and think about assembly-level programs. Downstream, the [assembler](#sec-assembler) then translates these pseudoinstructions into real instructions (e.g., `addi t1 t2 0`) in the ISA.

(sec-directives)=
:::{hint} Assembly Directives

Directives give directions to the assembler and are generated by the compiler. Directives do not produce **machine instructions**! Rather, they inform for downstream how to build parts of the output object file. See our [example](#code-hello-s).

:::

(sec-assembler)=
### Assembler

::::{note} ðŸŽ¥ Lecture Video
:class: dropdown

:::{iframe} https://www.youtube.com/embed/87YbZ9x8QEY
:width: 100%
:title: "[CS61C FA20] Lecture 13.3 - Compilation, Assembly, Linking, Loading: Assembler"
:::

to 1:26

::::

The assembler translates assembly code to machine modules. It translates **pseudoinstructions** to real instructions and produces an **object file**. The assembler uses assembly **directives** to produce the object file, which contains portions of an executable's **text segment**, **data segment**, and more. 

:::{hint} Read more about how the assembler builds an object file

Remember assembly instruction [labels](#sec-labels)? The assembler can resolve some labels (i.e., translate into machine code) if they involve **PC-relative addressing** within the same module.

However, the assembler doesnâ€™t know where headers are located (e.g., C standard libraries); it delegates this resolution to the Linker, downstream. The output of an assembler is therefore typically not a full executable; instead, the **object file** is a **machine language module** that contains both this moduleâ€™s instructions and information for downstream steps (e.g., linking) and debugging.

We provide more details for creating the object file in a [later section](#sec-assembler-details).
:::

(sec-linker)=
### Linker

::::{note} ðŸŽ¥ Lecture Video
:class: dropdown

:::{iframe} https://www.youtube.com/embed/2lVYrK7spaw
:width: 100%
:title: "[CS61C FA20] Lecture 13.4 - Compilation, Assembly, Linking, Loading: Linker"
:::

until 1:38
::::

The linker patches together multiple object modules to produce an executable. It resolves all the assembler's "TODO items," including **relocating** everything for the final executable:

1. Put together **text segments** from each `.o` file.
1. Put together data segments from each `.o` file, then  concatenate this onto the end of Step 1â€™s segment.
1. Resolve references, i.e., addresses that the assembler wasn't able to resolve.

:::{figure} images/linker-flow.png
:width: 40%
:alt: "TODO"
:::

The linker enables **separate compilation** of different parts of the program. Importantly, it supports not _recompiling_ larger libraries. For example,. C standard libraries (e.g., `stdio`) are part of the Linux source, which is over 20 million lines of code. Because of the linker, recompiling a simple `foo.c` does not require recompiling `stdio` :-)

:::{hint} Read more about how the linker resolves references

The linker updates **absolute addresses** because it know the full size of the executable's text and data segments. Read more in a [later section](#sec-linker-details). This section also talks about statically linked and dynamically linked libraries.

:::

:::{hint} What's in an executable?

The executable `a.out` contains both machine code (`text` segment) and static data (`data` segment). An executable also includes a header (to specify where these segments are in the file) and debugging information.

:::

(sec-loader)=
### Loader

::::{note} ðŸŽ¥ Lecture Video
:class: dropdown

:::{iframe} https://www.youtube.com/embed/E9zh8pobPNw
:width: 100%
:title: "[CS61C FA20] Lecture 13.5 - Compilation, Assembly, Linking, Loading: Loader"
:::

::::

The loader does several things to run a program. To learn more, we strongly recommend taking an upper-division class like CS 162: Operating Systems!

**1. Load program into a newly created address space** in memory.[^vm]

[^vm]: We discuss virtual memory in a later chapter.

* Read `a.out` file header for sizes of text, data segments.
* Create new address space for program large enough to hold **text and data segments**, along with a stack segment.
  * Copy instructions, data from executable file into new address space.
  * Copy arguments passed to the program onto the stack.

**2. Initialize machine registers**. Clear registers, and assign stack pointer `sp` to the assigned address of the first free stack location.

**3. Jump to start-up routine**:
Copy program arguments from stack to registers, set program counter `pc`. 

**4. Run the program**. If main routine returns, terminate program with exit system call.


