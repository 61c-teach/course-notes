<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Words, Endianness</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="endianness_files/libs/clipboard/clipboard.min.js"></script>
<script src="endianness_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="endianness_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="endianness_files/libs/quarto-html/popper.min.js"></script>
<script src="endianness_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="endianness_files/libs/quarto-html/anchor.min.js"></script>
<link href="endianness_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="endianness_files/libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="endianness_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="endianness_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="endianness_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Words, Endianness</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="learning-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="learning-outcomes">Learning Outcomes</h2>
<ul>
<li>Gain an intuition of how hardware word size can impact memory layout of a compiled C program.</li>
<li>Differentiate between 32-bit and 64-bit architectures.</li>
<li>Read memory layouts of C programs compiled on little endian machines.</li>
<li>Understand how padding and packing can impact the memory layout of members within a C struct.</li>
</ul>
<p>No lecture video.</p>
</section>
<section id="words" class="level2">
<h2 class="anchored" data-anchor-id="words">Words</h2>
<p>What’s in a word? In computer architecture, a hardware <strong>word</strong> is an important unit of data. The word size determines many aspects of a computer’s structure and operation, from how to load and store data from memory to how the compiler translates a single C arithmetic operation into multiple assembly instructions.</p>
<p>On most modern architectures, the size of the word determines the <strong>largest possible address size</strong> and therefore the size of a C pointer. A 32-bit architecture has a word size of 32 bits, or 4 bytes. A 64-bit architecture has a word size of 64 bits, or 8 bytes.</p>
<p>:::{tip} Quick check</p>
<p>On a 32-bit architecture, what is <code>sizeof(int *)</code>? <code>sizeof(char *)</code>? :::</p>
<p>:::{note} Show answer :class: dropdown</p>
<p>All pointers on a 32-bit architecture are 4 bytes wide, so <code>sizeof(int *)</code> is <code>sizeof(char *)</code> is <code>sizeof(int **)</code> is 4. :::</p>
<p>We will cover hardware words in much more detail when we learn about instruction set architectures. For now, we use the notion of a word to remind us that compiled C programs produce memory layouts that are <em>architecture-dependent</em>. We discuss a few architecture-dependent characteristics of compiled programs below.</p>
</section>
<section id="address-space" class="level2">
<h2 class="anchored" data-anchor-id="address-space">Address Space</h2>
<p>The <strong>address space</strong> is the hypothetical range of addressable memory locations on a particular machine. For example, a 32-bit architecture, a pointer can address <span class="math inline">\(2^32\)</span> locations in memory<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Because memory is byte-addressable and contiguous, our address space size for a program is therefore <span class="math inline">\(2^32\)</span> bytes (or 4 GiB, “four gibi-bytes”. We cover this notation later).</p>
<p>Before we discuss our example, we’d like to share a diagram of memory that, while confusing at first glance, will be extremely useful in interpreting the memory layout of any compiled C program.</p>
<p>Memory on a 32-bit architecture is laid out as a very long array of <span class="math inline">\(2^32\)</span> bytes. A very long array would not fit on any page, whether horizontally or vertically. Instead, we use a visualization like <span class="citation" data-cites="tab-mem-layout">@tab-mem-layout</span>, which shows memory as rows of 4 bytes, from low to high addresses:</p>
<ul>
<li>In the rightmost four columns, “xx” values refer to data (hypothetical or otherwise) at each of four bytes of memory. These four bytes have contiguous memory addresses.</li>
<li>The leftmost column denotes the <em>lowest</em> address of the bytes in that row, i.e., the address of the rightmost byte.</li>
<li>In a given row, the rightmost byte has the lowest address, and the leftmost byte has the highest address. This is explained by the +3, +2, +1, and +0 headers.</li>
</ul>
<p>:::{table} Memory is a very long array of bytes, but this diagram “wraps” the long array into rows of 4 bytes. :label: tab-mem-layout :align: center</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">address</th>
<th style="text-align: left;">+3</th>
<th style="text-align: left;">+2</th>
<th style="text-align: left;">+1</th>
<th style="text-align: left;">+0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0x0</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x4</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>...</code></td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0xFFFFFFF8</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0xFFFFFFFC</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
</tbody>
</table>
<p>:::</p>
<p>:::{note} Example byte addresses :class: dropdown</p>
<ul>
<li>The upper-right “xx” is at adddress <code>0x0000000</code>, or <code>0b0000 0000 ... 0000 0000</code>. This is the lowest possible address in the 32-bit address space.</li>
<li>The upper-left “xx” is at address <code>0x00000003</code>, or <code>0b0000 0000 ... 0000 0011</code>.</li>
<li>The bottom-right “xx” is at address <code>0xFFFFFFC</code>, or <code>0b1111 1111 ... 1111 1100</code>.</li>
<li>The bottom-left “xx” is at address <code>0xFFFFFFFF</code>, or <code>0b1111 1111 ... 1111 1111</code>. This is the highest possible address in the 32-bit address space.</li>
</ul>
<p>:::</p>
<p>A notable property of this visualization is that the addresses in the left column are multiples of 4. This layout effectively aligns our memory layout to <strong>words</strong>, because a 32-bit architecture has 4-byte words.</p>
<p>A confusing property of this visualization is that “lower” addresses are in earlier rows, whereas “higher” addresses are in later rows. This is not great for those of us that value meaningful naming conventions. However, when displaying large ranges of memory using debuggers like <code>gdb</code>, command-line output often displays data starting from lower addresses first, just like in this visualization.</p>
</section>
<section id="compiled-program-example" class="level2">
<h2 class="anchored" data-anchor-id="compiled-program-example">Compiled program example</h2>
<p>Suppose that the following C program is compiled on a 32-bit architecture and produces the memory layout in <span class="citation" data-cites="tab-word-program">@tab-word-program</span>.</p>
<p>(word-program)=</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> value <span class="op">=</span> <span class="bn">0x12345678</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> str1<span class="op">[]</span> <span class="op">=</span> <span class="st">"hi!"</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> str2<span class="op">[]</span> <span class="op">=</span> <span class="st">"cs61c"</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int16_t</span> short_val <span class="op">=</span> <span class="bn">0xaabb</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>:::{table} Data layout of program on a 32-bit little endian machine. :label: tab-word-program :align: center</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">address</th>
<th style="text-align: left;">+3</th>
<th style="text-align: left;">+2</th>
<th style="text-align: left;">+1</th>
<th style="text-align: left;">+0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0x0</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x4</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>...</code></td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x7F...FE164</code></td>
<td style="text-align: left;"><code>0xaa</code></td>
<td style="text-align: left;"><code>0xbb</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x7F...FE168</code></td>
<td style="text-align: left;"><code>0x12</code></td>
<td style="text-align: left;"><code>0x34</code></td>
<td style="text-align: left;"><code>0x56</code></td>
<td style="text-align: left;"><code>0x78</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x7F...FE16C</code></td>
<td style="text-align: left;"><code>'i'</code></td>
<td style="text-align: left;"><code>'h'</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x7F...FE170</code></td>
<td style="text-align: left;"><code>'s'</code></td>
<td style="text-align: left;"><code>'c'</code></td>
<td style="text-align: left;"><code>'\0'</code></td>
<td style="text-align: left;"><code>'!'</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x7F...FE174</code></td>
<td style="text-align: left;"><code>'\0'</code></td>
<td style="text-align: left;"><code>'c'</code></td>
<td style="text-align: left;"><code>'1'</code></td>
<td style="text-align: left;"><code>'6'</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x7F...FE178</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>...</code></td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0xFFFFFFFC</code></td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
</tr>
</tbody>
</table>
<p>:::</p>
<p>:::{tip} Quick Check</p>
<p>Determine the addresses of <code>value</code> and <code>str1</code>. :::</p>
<p>:::{note} Answer</p>
<p>Recall that the address of a stored value is the <strong>lowest</strong> address among the bytes of that value.</p>
<ul>
<li><p><code>value</code> (the 32-bit signed integer 305419896 in decimal) has four bytes: <code>0x12</code>, <code>0x34</code>, <code>0x56</code>, and <code>0x78</code>. The lowest address of these four bytes is the address of the byte <code>0x78</code>, which is <code>0x7FFFE168</code>.</p></li>
<li><p><code>str</code> is the C-string <code>"hi!"</code> which has four bytes including the null-terminator: <code>'h'</code>, <code>'i'</code>, <code>'!'</code>, <code>'\0'</code>. The lowest address of these bytes is the address of <code>'h'</code>, which is <code>0x7FFFE16C</code> + 2, or <code>0x7FFFE16E</code>.</p></li>
</ul>
<p>:::</p>
<p>There are two architecture-dependent aspects of this memory layout:</p>
<ol type="1">
<li>The bytes of <code>value</code> appear to be stored in “reverse” order. The least significant byte, <code>0x78</code>, has the lowest address!</li>
<li>The word-sized <code>value</code> has address <code>0x7FFFE168</code>, which is a multiple of four.</li>
</ol>
<p>Together, these two observations tell us that the architecture is <strong>little endian</strong>, and that 32-bit integers (and perhaps other word-sized values) are <strong>word-aligned</strong>.</p>
</section>
<section id="endianness" class="level2">
<h2 class="anchored" data-anchor-id="endianness">Endianness</h2>
<p>When data occupies multiple contiguous bytes in memory, the computer must determine which of the bytes is stored at the lowest address. This decision is often informed by the hardware architecture and in what order bytes are read from memory.</p>
<p>This property is called <strong>endianness</strong>. For a given word:</p>
<ul>
<li><strong>Little endian</strong> machines store the <em>least_significant byte</em> first, at the lowest address of the word.</li>
<li><strong>Big endian</strong> machines store the <em>most</em> significant byte_ first, at the lowest address of the word.</li>
</ul>
<p>The choice of endianness is one of convention<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Nearly all modern computer architectures are little endian.</p>
<p>:::{tip} Quick check</p>
<p>How does the diagram in <span class="citation" data-cites="tab-word-program">@tab-word-program</span> help us read 32-bit integers? :::</p>
<p>:::{note} Answer</p>
<p>The 32-bit architecture is <strong>little endian</strong>. We know this because the integer <code>0x12345678</code> has least significant byte, <code>0x78</code> which is stored first at the lowest address.</p>
<p>In <span class="citation" data-cites="tab-word-program">@tab-word-program</span>, data columns are enumerated in reverse order: +3, +2, +1, +0. This helps us read numbers in <strong>human format</strong>, e.g., <code>0x12</code> is on the left, and <code>0x78</code> is on the right.</p>
<p>:::</p>
<p>Read more about endianness on <a href="https://en.wikipedia.org/wiki/Endianness">Wikipedia</a>.</p>
</section>
<section id="alignment" class="level2">
<h2 class="anchored" data-anchor-id="alignment">Alignment</h2>
<section id="word-alignment" class="level3">
<h3 class="anchored" data-anchor-id="word-alignment">Word Alignment</h3>
<p>One critical operation that the hardware word defines is memory access. As we shall see, many architectures are optimized to <em>word-aligned</em> memory access. This means that it is very fast to access an entire word when that word is located at a memory address that is a multiple of the word size. For a 32-bit architecture, this means reading 4 bytes, where the first byte lies on a 4-byte boundary.</p>
<p>Of the four variables in <span class="citation" data-cites="word-program">@word-program</span>, only <code>value</code> is the size of a word. The compiler has therefore aligned <code>value</code> to a word boundary. The other variables <code>str1</code>, <code>str2</code>, and <code>short_val</code> do not have values that are word-sized and therefore do not have such a constraint.</p>
</section>
<section id="struct-alignment" class="level3">
<h3 class="anchored" data-anchor-id="struct-alignment">Struct Alignment</h3>
<p>Let us revisit the idea of a <code>struct</code>. and consider how much space each declared <code>struct</code> occupies.</p>
<p>:::{card} Data structure alignment From <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Wikipedia</a>: ^^^ Data structure alignment is the way data is arranged and accessed in computer memory. It consists of three separate but related issues: data alignment, data structure padding, and packing.</p>
<p><em>Data alignment</em> is the aligning of elements according to their natural alignment. To ensure natural alignment, it may be necessary to insert some <em>padding</em> between structure elements or after the last element of a structure. For example, on a 32-bit machine, a data structure containing a 16-bit value followed by a 32-bit value could have 16 bits of padding between the 16-bit value and the 32-bit value to align the 32-bit value on a 32-bit boundary. Alternatively, one can <em>pack</em> the structure, omitting the padding, which may lead to slower access, but saves 16 bits of memory. :::</p>
<p>Consider the <code>foo</code> struct:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> a<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> b<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> foo <span class="op">*</span>c<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By themselves, a 32-bit integer, and character, and a struct pointer occupy 9 bytes. However, when declared together as a struct, C compilers may often choose to introduce <strong>padding</strong> into the struct itself to align the members of the struct. Padding a struct allows operations on its members to leverage the same speedups from word alignment had the members been declared separately.</p>
<p>:::{table} Structs can introduce byte padding. On the below 32-bit architecture, <code>sizeof(struct foo)</code> is 12. :label: tab-struct :align: center</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">+3</th>
<th style="text-align: left;">+2</th>
<th style="text-align: left;">+1</th>
<th style="text-align: left;">+0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">AA</td>
<td style="text-align: left;">AA</td>
<td style="text-align: left;">AA</td>
<td style="text-align: left;">AA</td>
</tr>
<tr class="even">
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">xx</td>
<td style="text-align: left;">BB</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CC</td>
<td style="text-align: left;">CC</td>
<td style="text-align: left;">CC</td>
<td style="text-align: left;">CC</td>
</tr>
</tbody>
</table>
<p>:::</p>
<p>:::{note} Explanation :class: dropdown</p>
<p>Suppose we declare <code>struct foo s;</code> and compile a program onto a 32-bit architecture. We might see <span class="citation" data-cites="tab-struct">@tab-struct</span> as above.</p>
<ul>
<li>AA denotes the four bytes occupied by <code>s.a</code>. <code>sizeof(s.a)</code> is 4.</li>
<li>BB denotes the single byte occupied by <code>s.b</code>. <code>sizeof(s.b)</code> is 1. The precise alignment of <code>s.b</code> is implementation-specific.</li>
<li>CC denotes the four bytes occupied by the <code>s.c</code>. <code>sizeof(s.c)</code> is 3.</li>
</ul>
<p>:::</p>
<p>Ultimately, the <code>struct</code> declaration is a guideline for how to arrange a bunch of bytes in a bucket. The precise size of a struct—and field order within a struct type–depends on the C compiler and whether it is optimizing for padding or packing. We recommend you always check sizes with a debugger like <code>gdb</code>.</p>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Logically, not in practice. Some areas of memory are read/write protected, e.g., accessing memory at the address <code>0</code> (<code>NULL</code>) causes an error.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Endianness can also refer to the order in which bytes are transmitted over networks and other data communication media; most modern internet networks prefer big endian. See a relatively interesting discussion on <a href="https://www.reddit.com/r/learnprogramming/comments/1emdohb/can_someone_explain_to_me_why_therere_big_endian/">Reddit</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>